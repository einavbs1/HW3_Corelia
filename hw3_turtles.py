# -*- coding: utf-8 -*-
"""HW3_Turtles.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/13-Uz3UQoCc-f7BCbwgfkPuVZPAqZVDHs
"""

#installations - needs to run the first time.
!pip install firebase
!pip install requests beautifulsoup4
!pip install nltk
!pip install pandas
!pip install matplotlib
!pip install pillow
!pip install -q google-generativeai
!pip install bcrypt
!pip install pytz
!pip install sendgrid

#installations - needs to run the first time above.

#imports
import matplotlib.pyplot as plt
import matplotlib as mpl
import pandas as pd
import numpy as np
import io
import bcrypt
import base64
from datetime import timedelta, datetime
import pytz
import time
import threading
import random
import string
from PIL import Image
import re
from nltk.stem import PorterStemmer
import ipywidgets as widgets
from IPython.display import display, Javascript, HTML, clear_output
import os
import sys
import contextlib
import requests
from collections import Counter, defaultdict
#from google.colab import files
from firebase import firebase
from bs4 import BeautifulSoup
from urllib.parse import urljoin
from pickle import STRING
import json
import google.generativeai as genai
from IPython.display import display, Markdown
import sendgrid
from sendgrid.helpers.mail import Mail

#Global variables for managment the site
FBconn = firebase.FirebaseApplication('https://cloud-e4313-default-rtdb.firebaseio.com/', None)
SENDGRID_API_KEY = "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"
tabs = widgets.Tab()
month = datetime.now().strftime('%Y-%m')
today = datetime.now().strftime('%Y-%m-%d')

# Global variables for the admin page & user page
currKeyUserConnected = None
currUserisAdmin = None
lastUpdateUsersTable = None
usersInfoForAdminTable = None
currConnectedUserName = None
monitor_active = False
monitor_thread = None
admin_table_widget = widgets.HTML()
user_table_widget = widgets.HTML()
lastUpdateTasksUserTable = None



#global variable for the gaming page
tasks_dic = {}


########################################################
########################################################
############~ Start index to FireBase DB ~##############

class IndexService:
    def __init__(self):
        self.documents = {}
        self.index = {}
        self.visited_urls = set()  # Track visited URLs to avoid duplicates
        self.max_links = 5  # Maximum number of links to follow from each page

    #Index a site starting from start_url and following links up to max_depth
    def index_site(self, start_url, max_depth=5):
        if max_depth <= 0 or start_url in self.visited_urls:
            return

        # Add the URL to visited set
        self.visited_urls.add(start_url)

        # Index the current page
        soup = self.fetch_page(start_url)
        if soup is None:
            return

        # Index the current page's content
        self.index_page_content(soup, start_url)

        # Find links on the page
        links = []
        for a_tag in soup.find_all('a', href=True):
            href = a_tag['href']
            # Create absolute URL
            full_url = urljoin(start_url, href)
            if full_url not in links:
              links.append(full_url)

        # Limit to max_links
        links = links[:self.max_links]

        # Follow links recursively
        for link in links:
            self.index_site(link, max_depth - 1)

    #Index the content of a page
    def index_page_content(self, soup, url):
      # Extract text and count words
      words = re.findall(r'[a-zA-Z]+', soup.get_text())  # return words
      words = [word.lower() for word in words]

      # Count word occurrences
      word_counts = dict(Counter(words))

      # Process the words
      word_counts = self.remove_stop_words(word_counts)
      word_counts = self.apply_stemming(word_counts)

      # Add to the index
      self.add_document(word_counts, url)

      return word_counts

    #Legacy method: Index a single page without following links
    def index_words(self, url):
        soup = self.fetch_page(url)
        if soup is None:
            return None

        return self.index_page_content(soup, url)

    #Add a document to the index
    def add_document(self, word_counts, url):
        # Store document content for reference
        doc_id = str(len(self.documents) + 1)
        self.documents[doc_id] = {
            'words': list(word_counts.keys()),
            'url': url
        }

        # Build the inverted index
        for word in word_counts.keys():
            if word not in self.index:
                self.index[word] = set()

            # Add the URL to the set for this word
            self.index[word].add(url)

        return self.documents[doc_id]

    #safe call for html page
    def fetch_page(self, url):
        try:
            # Send an HTTP GET request to the URL
            response = requests.get(url, timeout=10)
            #successful request
            if response.status_code == 200:
                soup = BeautifulSoup(response.text, 'html.parser')
                return soup #Return the parsed HTML (soup object)
            else:
                print(f"Failed to fetch {url}: Status code {response.status_code}")
                return None
        except Exception as e:
            # Handle any exceptions that may occur during the request
            print(f"Error fetching {url}: {e}")
            return None


    def remove_stop_words(self, index):
        try:
            # reading stop words file from github.
            response = requests.get("https://raw.githubusercontent.com/einavbs1/HW2_Cloud/main/stopwords_en.txt")
            response.raise_for_status()  # ensuring there is not error
            stop_words = response.text.splitlines()
        except Exception as e:
            print(f"Error while reading stop words {e}")
            # deault stop words if file isnt avaiable
            stop_words = ['the', 'is', 'at', 'which', 'on', 'a']
        return {word: count for word, count in index.items() if word.lower() not in stop_words}


    #stemiming index words, using porterstemmer
    def apply_stemming(self, index):
        stemmer = PorterStemmer()
        stemmed_index = {}
        for word, count in index.items():
            stemmed_word = stemmer.stem(word)
            if stemmed_word in stemmed_index:
                stemmed_index[stemmed_word] += count
            else:
                stemmed_index[stemmed_word] = count
        return stemmed_index

    #Convert index with sets to dictionary format for Firebase
    def convert_index_for_firebase(self):
        firebase_index = {}
        for word, urls in self.index.items():
            firebase_index[word] = list(urls)
        return firebase_index

    #Retrieve all data records
    def load_index_from_firebase(self):

        firebase_data = FBconn.get('/myMqttIndex/', None)
        #Load index from Firebase format back to Python sets
        self.index = {}
        for word, urls in firebase_data.items():
            self.index[word] = set(urls)
        return self.index

    def add_index_to_firebase(self):
      firebase_index = self.convert_index_for_firebase()
      FBconn.patch('/myMqttIndex/', firebase_index)



#############~ End index to FireBase DB ~#################
########################################################
########################################################


########################################################
########################################################
############~ Start Search Engine page ~################


image_url = "https://raw.githubusercontent.com/einavbs1/HW2_Cloud/main/Corelia_Logo_Final.png"

logo_widget = widgets.HTML(
    value=f'<img src="{image_url}" width="500" height="380">'
)



tabs = widgets.Tab()
# CSS Styling (General + Table)
style = """
<style>
    html, body {
        background-color: #f4f4f4;
        margin: 0;
        height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
    }
    .main-container {
        background-color: #ffffff;
        border-radius: 16px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        padding: 30px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        width: 500px;
        min-height: 350px;
    }
    .search-input input {
        border-radius: 12px;
        border: 1px solid #ccc;
        padding: 10px;
        font-size: 16px;
        background-color: #f9f9f9;
        outline: none;
        width: 350px;
        transition: box-shadow 0.3s;
    }
    .search-input input:focus {
        box-shadow: 0 0 8px rgba(30, 144, 255, 0.5);
        border-color: #1E90FF;
    }
    .button-container {
        display: flex;
        gap: 15px;
        margin-top: 20px;
        margin-bottom: 20px;
    }
    .search-button, .lucky-button {
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        font-size: 14px;
        border-radius: 8px;
        padding: 10px 20px;
        border: none;
        cursor: pointer;
        height: 40px;
        transition: background-color 0.3s;
    }
    .search-button {
        background-color: #009ACD;
        color: white;
        width: 130px;
    }
    .search-button:hover {
        background-color: #007C8A;
    }
    .lucky-button {
        background-color: #4CAF50;
        color: white;
        width: 160px;
    }
    .lucky-button:hover {
        background-color: #228B22;
    }
    .custom-label {
        color: red;
        font-weight: bold;
        margin-top: 15px;
    }
    /* Table Styling */
    .results-table {
        border-collapse: collapse;
        width: 500px;
        margin: 30px auto;
        font-family: Arial, sans-serif;
        table-layout: auto;
    }
    .results-table th, .results-table td {
        text-align: left;
        padding: 12px;
        min-width: 50px;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }
    .results-table tr:nth-child(even) {
        background-color: #f2f2f2;
    }
    .results-table th {
        background-color: #4CAF50;
        color: white;
    }
    .results-table td a {
        color: #1E90FF;
        text-decoration: none;
    }
    .results-table td a:hover {
        text-decoration: underline;
    }
    .status-online, .first-place {
    background-color: #d4edda;
    color: #155724;
    font-weight: bold;
    }
    .status-offline, .last-place {
        background-color: #f8d7da;
        color: #721c24;
        font-weight: bold;
    }
    .status-unknown {
        background-color: #fff3cd;
        color: #856404;
        font-weight: bold;
    }
</style>
"""
display(widgets.HTML(value=style))
index_service = IndexService()

index_service.index_site("https://mqtt.org/")  # Perform the indexing on the site
index = index_service.convert_index_for_firebase()

# After performing indexing, upload the new index to Firebase
index_service.add_index_to_firebase()
tab1_content = widgets.Output()

#make the last tab toi unvisable if none results found.
def resetTabs():
    global tabs, currUserisAdmin
    currPage = tabs.selected_index if hasattr(tabs, 'selected_index') else 0
    tabs.children=[tab0_content,tab1_content,tab2_content,tab3_content, tab5_content, tab6_content]
    if currUserisAdmin == None :
      tabs.set_title(0, 'Login Page')
    elif currUserisAdmin:
      tabs.set_title(0, 'Admin Dashboard')
    else:
      tabs.set_title(0, 'User Dashboard')
    tabs.set_title(1, 'Graphs')
    tabs.set_title(2, 'Gamification')
    tabs.set_title(3, 'Search')
    tabs.set_title(4, 'Informations Transportation')
    tabs.set_title(5, 'Chatbot Assistant')
    tabs.selected_index = currPage


def readFile(fileName):
    with open(fileName, 'r', encoding="utf-8") as file:
        return file.read()


def remove_stop_words(query_list):
    try:
        # reading stop words file from github.
        response = requests.get("https://raw.githubusercontent.com/einavbs1/HW2_Cloud/main/stopwords_en.txt")
        response.raise_for_status()  # ensuring there is not error
        stop_words = response.text.splitlines()
    except Exception as e:
        print(f"Error while reading stop words {e}")
        # deault stop words if file isnt avaiable
        stop_words = ['the', 'is', 'at', 'which', 'on', 'a']
    return [word for word in query_list if word.lower() not in stop_words]

#steem words to root.
def apply_stemming(query_list):
    stemmer = PorterStemmer()
    return list(set(stemmer.stem(word).lower() for word in query_list))

#returns only the words thats in the index
def search(stemmed_query, index):
    results = {}
    for word in stemmed_query:
        if word in index:
            results[word] = index[word]
    return results

#This function is sorting the links from the most frequence to the last
def prioritize_pages(results):
    priority = {}
    for word, links in results.items():
        for link in links:
            priority[link] = priority.get(link, 0) + 1
    return dict(sorted(priority.items(), key=lambda item: item[1], reverse=True))

# UI Widgets
Query = widgets.Text(
    value='',
    placeholder='Enter your search...',
    layout=widgets.Layout(width='350px', height='40px')
)
Query.add_class("search-input")

searchBtn = widgets.Button(
    description="Search",
    layout=widgets.Layout(width='130px', height='40px')
)
searchBtn.add_class("search-button")

LuckyBtn = widgets.Button(
    description="I'm Feeling Lucky",
    layout=widgets.Layout(width='160px', height='40px')
)
LuckyBtn.add_class("lucky-button")

errMsg = widgets.Label(value='')
errMsg.add_class("custom-label")

searchResults = widgets.HTML(value='')

def saveUserSearchQuery():
    global currKeyUserConnected
    if currKeyUserConnected is None:
        return  # No user is connected, skip saving

    # Get the current search query
    query = Query.value.strip()
    if not query:
        return  # No query to save

    # Prepare the data to save
    data = {
        'query': query,
        'timestamp': datetime.now().isoformat()
    }
    lastSearches = []
    lastSearches = FBconn.get(f'/Login/Users/{currKeyUserConnected}/last5Searches', None) or []
    if len(lastSearches) >= 5:
        lastSearches.pop(0)  # Remove the oldest search if we have 5 already
    lastSearches.append(data)  # Add the new search query
    # Save the updated list back to Firebase
    FBconn.patch(f'/Login/Users/{currKeyUserConnected}/',{"last5Searches": lastSearches})
    FBconn.patch("/Login", {"lastupdate": datetime.now(TZ_IL).isoformat()})


#getting query from the search tab and finding results
def get_search_results():
    if Query.value.strip() == '':
        errMsg.value = 'Please enter a query.'
        return {}
    errMsg.value = ''
    words = Query.value.split()
    filtered = remove_stop_words(words)
    stemmed = apply_stemming(filtered)
    results = search(stemmed, index)
    saveUserSearchQuery()
    return prioritize_pages(results)

#if we needs to show results and the last tab is unvisable
def update_tabs():
    global tabs, currUserisAdmin
    currPage = tabs.selected_index if hasattr(tabs, 'selected_index') else 0
    if len(tabs.children) < 7:
        tabs.children = [tab0_content,tab1_content,tab2_content, tab3_content, tab4_content, tab5_content, tab6_content]
        if(currUserisAdmin):
            tabs.set_title(0, 'Admin Dashboard')
        else:
            tabs.set_title(0, 'User Dashboard')
        tabs.set_title(1, 'Graphs')
        tabs.set_title(2, 'Gamification')
        tabs.set_title(3, 'Search')
        tabs.set_title(4, 'Results')
        tabs.set_title(5, 'Informations Transportation')
        tabs.set_title(6, 'Chatbot Assistant')
    tabs.selected_index = currPage

#This function is openingh the results in the results last tab
def on_click_search(btn):
    results = get_search_results()
    if not results:
        errMsg.value = "No results found"
        resetTabs()
    else:
        update_tabs()
        table_html = "<table class='results-table'>"
        table_html += "<tr><th>#</th><th>Site</th><th>Link</th></tr>"
        for i, link in enumerate(results, start=1):
            link_url = f"https://{link}" if not link.startswith("http") else link
            domain = link.replace("https://", "").replace("http://", "")
            table_html += f"<tr><td>{i}</td><td>{domain}</td><td><a href='{link_url}' target='_blank'>Visit</a></td></tr>"
        table_html += "</table>"
        searchResults.value = table_html
        Query.value = ''
        # Refresh Tab 4 Content
        with tab4_content:
            tab4_content.clear_output()
            display(widgets.VBox([logo_widget, searchResults], layout=widgets.Layout(align_items='center')))

        tabs.selected_index = 4

#This function is openingh the best result in new tab and showing the link in the results last tab
def on_click_lucky(btn):
    # Get search results
    results = get_search_results()
    # If no results are found, display an error message and reset tabs
    if not results:
        errMsg.value = "No results found"
        resetTabs()
        return
    else:
      update_tabs()
      url = next(iter(results))
      # Ensure the URL starts with "http", if not, prepend "https://"
      link_url = f"https://{url}" if not url.startswith("http") else url
      display(Javascript(f"window.open('{link_url}', '_blank');"))
      searchResults.value = f"<p style='text-align:center; font-size: 18px;'>The best result is: <a href='{link_url}' target='_blank'>{link_url}</a><br>(Already opened for you.)</p>"
      Query.value = ''
      # Refresh Tab 4 Content
      with tab4_content:
            tab4_content.clear_output()
            display(widgets.VBox([logo_widget, searchResults], layout=widgets.Layout(align_items='center')))

      tabs.selected_index = 4


searchBtn.on_click(on_click_search)
LuckyBtn.on_click(on_click_lucky)
button_container = widgets.HBox([searchBtn, LuckyBtn])

# Create the main container for displaying the search interface, including logo, query, buttons, and error message
main_container = widgets.VBox(
    [logo_widget, Query, button_container, errMsg],
    layout=widgets.Layout(align_items='center', justify_content='center')
)

#############~ End Search Engine page ~#################
########################################################
########################################################

########################################################
########################################################
#################~ Start Graphs page ~##################


##################### Code from tut 03 that dosent works #####################
"""
××¦×¨×£ ××ª ×”×§×•×“ ×©××ª×‘×¡×¡ ×¢×œ ×ª×¨×’×•×œ 3 ×œ×œ×•×¤ ×©×œ ×”× ×ª×•× ×™× ×©×œ ×”×—×™×™×©× ×™×, ×‘×¤×•×¢×œ ×–×” ×œ× ×¢×•×‘×“ ×•×”×× ×§×™×•×˜×™×˜×™ ×œ× ××¤×‘×œ×© ×”×•×“×¢×•×ª ×œ×›×Ÿ ×”×©×ª××©× ×• ×‘×¤×™×™×§ ×“××˜×” ×©×œ × ×ª×•× ×™× ×©×”×¦×œ×—×—×ª×™ ×œ×—×œ×¥ ××”×—×™×™×©× ×™× ××”×–××Ÿ ×©×›×Ÿ ×¤×•×‘×œ×©×• ×”×•×“×¢×•×ª

import paho.mqtt.client as mqtt
import json

# Callback function for when a message is received
def on_message(client, userdata, msg):
    try:
        data = json.loads(msg.payload.decode())

        # Extract values with lowercase field names
        temperature = data.get("Temperature", "N/A")
        humidity = data.get("Humidity", "N/A")
        pressure = data.get("Pressure", "N/A")

        print(f"Temperature: {temperature}Â°C, Humidity: {humidity}%, Pressure: {pressure} hPa")

    except json.JSONDecodeError:
        print("Received invalid JSON data")

# MQTT setup
broker = "test.mosquitto.org"
topic = "braude/D106/indoor"

client = mqtt.Client()
client.on_message = on_message

client.connect(broker, 1883, 60)
client.subscribe(topic)

print(f"Subscribed to MQTT topic: {topic}")
client.loop_forever()
"""

##################### End of the code from tut 03 that dosent works #####################




mpl.rcParams['font.family'] = 'DejaVu Sans'
plt.switch_backend('agg')

# === Generate fake data ===
def generate_fake_data():
    end_date = datetime.now()
    date_range = [end_date - timedelta(days=i) for i in range(6)]
    date_range.reverse()
    english_days = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
    days_of_week = [english_days[d.weekday()] for d in date_range]

    # Existing sensor data
    avg_temps = [round(20 + random.random() * 6, 1) for _ in range(6)]
    avg_humidity = [round(40 + random.random() * 20, 1) for _ in range(6)]
    max_temps = [round(t + 2 + random.random() * 2, 1) for t in avg_temps]
    min_temps = [round(t - 2 - random.random() * 2, 1) for t in avg_temps]
    users = [round(10 + random.random() * 20) for _ in range(6)]
    avg_pressure = [round(1013 + random.uniform(-10, 10), 1) for _ in range(6)]

    # Daylight sensor data
    # Daylight hours per day (realistic range 8-14 hours depending on season/weather)
    daylight_hours = [round(random.uniform(9, 13), 1) for _ in range(6)]

    # Sunrise times (in hours, e.g., 6.5 = 6:30 AM)
    sunrise_times = [round(random.uniform(5.5, 7.0), 1) for _ in range(6)]

    # Sunset times (calculated from sunrise + daylight hours)
    sunset_times = [round(sunrise + daylight, 1) for sunrise, daylight in zip(sunrise_times, daylight_hours)]

    # Current daylight status
    current_hour = datetime.now().hour + datetime.now().minute / 60
    current_daylight_status = "Day" if 6 <= datetime.now().hour <= 18 else "Night"
    current_light_level = round(random.uniform(200, 1500), 0) if current_daylight_status == "Day" else round(random.uniform(0, 50), 0)

    # Current values for existing sensors
    current_temp = round(23.5 + (random.random() * 2 - 1), 1)
    current_humidity = round(48 + (random.random() * 8 - 4))
    current_active_users = 17 + (random.randint(-2, 2))
    current_pressure = round(1013 + random.uniform(-5, 5), 1)

    return {
        'days': days_of_week,
        'avg_temps': avg_temps,
        'max_temps': max_temps,
        'min_temps': min_temps,
        'avg_humidity': avg_humidity,
        'avg_pressure': avg_pressure,
        'users': users,
        # Daylight data
        'daylight_hours': daylight_hours,
        'sunrise_times': sunrise_times,
        'sunset_times': sunset_times,
        'current': {
            'temp': current_temp,
            'humidity': current_humidity,
            'pressure': current_pressure,
            'active_users': current_active_users,
            # Current daylight data
            'daylight_status': current_daylight_status,
            'light_level': current_light_level
        }
    }

def fig_to_img(fig):
    buf = io.BytesIO()
    fig.savefig(buf, format='png', bbox_inches='tight', dpi=150)
    buf.seek(0)
    img = Image.open(buf)
    plt.close(fig)  # Close figure to free memory
    return img

# === Existing Charts ===
def create_temp_humidity_chart(data):
    fig, ax1 = plt.subplots(figsize=(6, 3))
    ax1.set_xlabel('Day')
    ax1.set_ylabel('Temperature (Â°C)', color='salmon')
    plt.subplots_adjust(top=0.85)
    ax1.set_title('Average Daily Temperature Last 6 Days (Indoor Sensor)', pad=20)

    line1 = ax1.plot(data['days'], data['avg_temps'], color='salmon', marker='o', label='Temperature')
    ax1.tick_params(axis='y', labelcolor='salmon')

    ax2 = ax1.twinx()
    ax2.set_ylabel('Humidity (%)', color='turquoise')
    line2 = ax2.plot(data['days'], data['avg_humidity'], color='turquoise', marker='s', label='Humidity')
    ax2.tick_params(axis='y', labelcolor='turquoise')

    lines = line1 + line2
    labels = [l.get_label() for l in lines]
    ax1.legend(lines, labels, bbox_to_anchor=(0.02, 0.98), loc='upper left')

    fig.tight_layout()
    return fig_to_img(fig)

def create_pressure_chart(data):
    fig, ax = plt.subplots(figsize=(6, 3))
    ax.plot(data['days'], data['avg_pressure'], color='purple', marker='o')
    ax.axhline(y=1013.25, color='gray', linestyle='--', label='Standard Pressure (1013.25 hPa)')
    ax.set_ylabel('Pressure (hPa)')
    ax.set_title('Barometric Pressure - Last 6 Days (Indoor Sensor)')
    ax.legend()
    fig.tight_layout()
    return fig_to_img(fig)

def create_users_chart(data):
    fig, ax = plt.subplots(figsize=(6, 3))
    ax.bar(data['days'], data['users'], color='cornflowerblue')
    ax.set_ylabel('Number of Users')
    ax.set_title('User Activity Per Day Of the Last week')
    fig.tight_layout()
    return fig_to_img(fig)

def create_temp_range_chart(data):
    fig, ax = plt.subplots(figsize=(6, 3))
    ax.fill_between(data['days'], data['min_temps'], data['max_temps'], color='skyblue', alpha=0.3)
    ax.plot(data['days'], data['max_temps'], color='salmon', marker='o', label='Maximum Temperature')
    ax.plot(data['days'], data['min_temps'], color='deepskyblue', marker='o', label='Minimum Temperature')
    ax.set_ylabel('Temperature (Â°C)')
    ax.set_title('Min Max Temperature Per Day - Last 6 Days (Indoor Sensor)')
    ax.legend()
    fig.tight_layout()
    return fig_to_img(fig)

# === NEW: Daylight Charts ===
def create_daylight_hours_chart(data):
    fig, ax = plt.subplots(figsize=(6, 3))
    bars = ax.bar(data['days'], data['daylight_hours'], color='gold', alpha=0.8)
    ax.set_ylabel('Hours')
    ax.set_title('Daylight Hours Per Day - Last 6 Days (Outdoor Sensor)')
    ax.set_ylim(0, 15)

    # Add value labels on bars
    for bar, hours in zip(bars, data['daylight_hours']):
        ax.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.1,
                f'{hours}h', ha='center', va='bottom', fontsize=10)

    fig.tight_layout()
    return fig_to_img(fig)

def create_sun_times_chart(data):
    fig, ax = plt.subplots(figsize=(6, 3))

    # Convert times to hours for plotting
    sunrise_hours = data['sunrise_times']
    sunset_hours = data['sunset_times']

    ax.plot(data['days'], sunrise_hours, color='orange', marker='o', label='Sunrise', linewidth=2)
    ax.plot(data['days'], sunset_hours, color='red', marker='s', label='Sunset', linewidth=2)

    # Fill area between sunrise and sunset to show daylight period
    ax.fill_between(data['days'], sunrise_hours, sunset_hours, color='yellow', alpha=0.2, label='Daylight Period')

    ax.set_ylabel('Time (24h format)')
    ax.set_title('Sunrise & Sunset Times - Last 6 Days (Outdoor Sensor)')
    ax.set_ylim(0, 24)

    # Format y-axis to show time format
    y_ticks = [0, 6, 12, 18, 24]
    y_labels = ['00:00', '06:00', '12:00', '18:00', '24:00']
    ax.set_yticks(y_ticks)
    ax.set_yticklabels(y_labels)

    ax.legend()
    ax.grid(True, alpha=0.3)
    fig.tight_layout()
    return fig_to_img(fig)

# === Updated Info Cards ===
def create_info_html(current):
    return f"""
    <div style='display: flex; gap: 20px; justify-content: center; font-family: Arial; font-size: 16px; flex-wrap: wrap'>
        <div style='background: #fff; border-radius: 12px; padding: 16px; box-shadow: 0 0 10px rgba(0,0,0,0.1); width: 180px; text-align: center; margin: 10px'>
            <div style='font-size: 40px;'>ğŸŒ¡ï¸</div>
            <strong style='color: black;'>Current Temperature</strong><br>
            <span style='color: black; font-size: 24px;'>{current['temp']}Â°C</span><br>
            <small style='color: black;'>Comfortable temperature</small>
        </div>
        <div style='background: #fff; border-radius: 12px; padding: 16px; box-shadow: 0 0 10px rgba(0,0,0,0.1); width: 180px; text-align: center; margin: 10px'>
            <div style='font-size: 40px;'>ğŸ’§</div>
            <strong style='color: black;'>Current Humidity</strong><br>
            <span style='color: black; font-size: 24px;'>{current['humidity']}%</span><br>
            <small style='color: black;'>Comfortable humidity</small>
        </div>
        <div style='background: #fff; border-radius: 12px; padding: 16px; box-shadow: 0 0 10px rgba(0,0,0,0.1); width: 180px; text-align: center; margin: 10px'>
            <div style='font-size: 40px;'>ğŸ”„</div>
            <strong style='color: black;'>Current Pressure</strong><br>
            <span style='color: black; font-size: 24px;'>{current['pressure']} hPa</span><br>
            <small style='color: black;'>Normal pressure</small>
        </div>
        <div style='background: #fff; border-radius: 12px; padding: 16px; box-shadow: 0 0 10px rgba(0,0,0,0.1); width: 180px; text-align: center; margin: 10px'>
            <div style='font-size: 40px;'>ğŸ‘¥</div>
            <strong style='color: black;'>Active Users</strong><br>
            <span style='color: black; font-size: 24px;'>{current['active_users']}</span><br>
            <small style='color: black;'>Normal activity</small>
        </div>
        <div style='background: #fff; border-radius: 12px; padding: 16px; box-shadow: 0 0 10px rgba(0,0,0,0.1); width: 180px; text-align: center; margin: 10px'>
            <div style='font-size: 40px;'>â˜€ï¸</div>
            <strong style='color: black;'>Daylight Status</strong><br>
            <span style='color: black; font-size: 24px;'>{current['daylight_status']}</span><br>
            <small style='color: black;'>{current['light_level']} lux</small>
        </div>
    </div>
    """

# === Dashboard update ===
def update_dashboard():
    data = generate_fake_data()
    cards = create_info_html(data['current'])
    return (
        cards,
        create_temp_humidity_chart(data),
        create_pressure_chart(data),
        create_users_chart(data),
        create_temp_range_chart(data),
        create_daylight_hours_chart(data),
        create_sun_times_chart(data)
    )

def pil_to_widget_img(pil_img):
    buf = io.BytesIO()
    pil_img.save(buf, format='PNG')
    return widgets.Image(value=buf.getvalue(), format='png', width=500, height=300)

def create_demo():
    cards, temp_humidity_img, pressure_img, users_img, temp_range_img, daylight_hours_img, sun_times_img = update_dashboard()
    return widgets.VBox([
        widgets.HTML(value=cards),
        pil_to_widget_img(temp_humidity_img),
        pil_to_widget_img(pressure_img),
        pil_to_widget_img(users_img),
        pil_to_widget_img(temp_range_img),
        pil_to_widget_img(daylight_hours_img),
        pil_to_widget_img(sun_times_img)
    ], layout=widgets.Layout(align_items='center'))

refresh_button = widgets.Button(
    description="ğŸ” Refresh Data",
    layout=widgets.Layout(width='200px', height='40px', margin='0px 0px 40px 0px')
)

def refresh_dashboard(btn=None):
    tab1_content.clear_output(wait=True)
    with tab1_content:
        display(widgets.VBox(
            [logo_widget, refresh_button],
            layout=widgets.Layout(align_items='center', justify_content='center', gap='20px')
        ))

        # Load updated content including new daylight charts
        cards, temp_humidity_img, pressure_img, users_img, temp_range_img, daylight_hours_img, sun_times_img = update_dashboard()
        display(widgets.HTML(value=cards))

        display(widgets.VBox(
            [
                pil_to_widget_img(temp_humidity_img),
                pil_to_widget_img(pressure_img),
                pil_to_widget_img(users_img),
                pil_to_widget_img(temp_range_img),
                pil_to_widget_img(daylight_hours_img),
                pil_to_widget_img(sun_times_img)
            ],
            layout=widgets.Layout(
                align_items='center',
                justify_content='center',
                display='flex',
                flex_direction='column',
                gap='100px'
            )
        ))

refresh_button.on_click(refresh_dashboard)

##################~ End Graphs page ~###################
########################################################
########################################################


########################################################
########################################################
##################~ Start Admin page ~###################


# Create widgets for entering the username and password
username_field = widgets.Text(
    description="Username:",
    placeholder="Enter username",
    layout=widgets.Layout(width='300px')
)

password_field = widgets.Password(
    description="Password:",
    placeholder="Enter password",
    layout=widgets.Layout(width='300px')
)


style_login_button = """
<style>
    .login-button, .resetMyPassword_btn {
        background-color: #4CAF50;
        color: white;
        border: none;
        padding: 8px 16px;
        font-size: 17px;
        border-radius: 8px;
        cursor: pointer;
        transition: background-color 0.3s, transform 0.3s;
        margin: 0 auto;
        display: block;
    }

    .login-button, resetMyPassword_btn :hover {
        background-color: #388E3C;
    }

    .button-container {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 15px;
        margin-top: 20px;
        margin-bottom: 20px;
    }
</style>
"""

display(widgets.HTML(value=style_login_button))


#forgot password btn
forgotPassword_btn = widgets.Button(
    description="Forgot your password?",
    layout=widgets.Layout(width='300px')
)

forgotPassword_btn.add_class("forgotPassword_btn")

#reset my password btn
resetMyPassword_btn = widgets.Button(
    description="Reset My Password",
    layout=widgets.Layout(width='300px' , height='50px')
)

resetMyPassword_btn.add_class("resetMyPassword_btn")

#back to login btn
backToLogin_btn = widgets.Button(
    description="Back to Login",
    layout=widgets.Layout(width='300px')
)

backToLogin_btn.add_class("backToLogin_btn")

#error message
login_error_message = widgets.Label(
    value="",
    style={'color': 'red'}
)



def create_index_inspector():
    # Create a text input widget for searching words in the index
    index_word_search_input = widgets.Text(
        placeholder='Search word in index...',
        layout=widgets.Layout(width='400px', height='40px')
    )

    # Create an output widget to display the indexed words
    index_word_box = widgets.Output(layout=widgets.Layout(
        border='1px solid #ccc',
        width='400px',
        height='300px',
        overflow_y='scroll',
        padding='10px',
        font_family='monospace'
    ))

    # Create a button to refresh the index
    refresh_index_btn = widgets.Button(
        description=' Refresh Index',
        layout=widgets.Layout(width='180px')
    )

    # Create a button to export the words
    export_btn = widgets.Button(
        description=' Export Words',
        layout=widgets.Layout(width='180px'),
        button_style='info'
    )


    export_status = widgets.Label(value="")
    current_index_words = []
    stemmer = PorterStemmer()

    # Function to load indexed words from Firebase and store them in the current_index_words list
    def load_index_words():
        nonlocal current_index_words
        index_service.load_index_from_firebase()
        index = index_service.convert_index_for_firebase()
        current_index_words = sorted(index.keys())

    # Function to update the word box that displays the indexed words, based on the search input
    def update_index_word_box(change=None):
        search_text = index_word_search_input.value.strip()
        search_stem = stemmer.stem(search_text.lower()) if search_text else ""
        filtered = [word for word in current_index_words if search_stem in word]

        with index_word_box:
            # Clear the current output of the word box
            index_word_box.clear_output()

            # If there's a search text, print the search details
            if search_text:
                print(f' Search: "{search_text}" â†’ Stem: "{search_stem}"')
                print('-' * 40)

            # Print each filtered word (those matching the search stem)
            for word in filtered:
                print(word)

    # Function to handle refreshing the index from Firebase and updating the word box
    def refresh_index_handler(btn):
        load_index_words()
        update_index_word_box()
        export_status.value = "Index refreshed from Firebase"

    # Function to export the indexed words to a text file
    def export_index_words_to_txt(btn):
        # If there are no words to export, update the status
        if not current_index_words:
            export_status.value = "No words to export."
            return

        try:
            file_path = "index_words_export.txt"
            with open(file_path, 'w', encoding='utf-8') as f:
                # Write each word in the current index to the file
                for word in current_index_words:
                    f.write(word + '\n')

            # Update the status
            export_status.value = f"âœ… Exported to: {os.path.abspath(file_path)}"

            # ××¤×©×¨×•×ª ×œ×¤×ª×•×— ××ª ×”×§×•×‘×¥ ××•×˜×•××˜×™×ª (×œ× ×—×•×‘×”)
            import webbrowser
            webbrowser.open('file://' + os.path.realpath(file_path))

        except Exception as e:
            export_status.value = f"âŒ Error: {str(e)}"


    # Set up the search input observer to update the word box whenever the value changes
    index_word_search_input.observe(update_index_word_box, names='value')

    # Set up the refresh button click handler
    refresh_index_btn.on_click(refresh_index_handler)

    # Set up the export button click handler
    export_btn.on_click(export_index_words_to_txt)


    # Load the words initially
    load_index_words()
    update_index_word_box()

    #return the widgets with the results
    return widgets.VBox([
        widgets.HTML('<h4>Indexed Words Overview</h4>'),
        index_word_search_input,
        index_word_box,
        widgets.HBox([refresh_index_btn, export_btn], layout=widgets.Layout(justify_content='center', gap='20px')),
        export_status
    ], layout=widgets.Layout(align_items='center', padding='20px'))



def get_users_info_from_db():
    global usersInfoForAdminTable
     # get all users information
    currentUsers = get_all_users()

    #create users table
    users_info = []
    for user_id, user in currentUsers.items():
        name = user.get('name', 'Unknown name')
        username = user.get('username', 'Unknown username')
        lastLogin = user.get('lastLogin', 'Unknown lastlogin')
        lastSeen = user.get('lastSeen', 'Unknown lastseen')
        # Check if both dates are available
        if lastLogin and lastSeen:
            # Convert lastLogin and lastSeen from ISO format string to datetime objects
            try:
                # Convert to datetime objects
                lastLogin_dt = datetime.fromisoformat(lastLogin)
                lastSeen_dt = datetime.fromisoformat(lastSeen)

                # Convert both to aware datetime objects with timezone
                tz_il = pytz.timezone("Asia/Jerusalem")
                lastLogin_dt = tz_il.localize(lastLogin_dt) if lastLogin_dt.tzinfo is None else lastLogin_dt
                lastSeen_dt = tz_il.localize(lastSeen_dt) if lastSeen_dt.tzinfo is None else lastSeen_dt


                # Compare dates
                if lastSeen_dt > lastLogin_dt:
                    status = "offline<br>" + "last seen at: " + lastSeen_dt.strftime("%Y-%m-%d %H:%M:%S")
                elif lastSeen_dt < lastLogin_dt:
                    status = "online<br>" + "logged in at: " + lastLogin_dt.strftime("%Y-%m-%d %H:%M:%S")
                else:
                    status = "didn't login yet"
            except ValueError:
                status = "unknown (val error)"
        else:
            status = "unknown (lastLogin or lastSeen missing)"
        last5Searchs = user.get('last5Searches', 'Unknown searchs')
        if isinstance(last5Searchs, list):
            searchText = ""
            for i, item in enumerate(last5Searchs, start=1):
                query_text = item.get("query", "Unknown")
                searchText += f"{i}. {query_text}<br>"
            last5Searchs = searchText
        isAdmin = user.get('isAdmin', False)
        users_info.append((name, username, status, last5Searchs, isAdmin))

    usersInfoForAdminTable = users_info


def _monitor_loop():
    global monitor_active, lastUpdateUsersTable, usersInfoForAdminTable

    while monitor_active:
        monitor_active = True
        try:
            print("Monitoring for changes in user data...")
            # Get current lastupdate value from Firebase
            new_update = FBconn.get("/Login/lastupdate", None)

            if new_update and new_update != lastUpdateUsersTable:
                lastUpdateUsersTable = new_update

                # Re-fetch users from DB
                get_users_info_from_db()
                update_admin_table_only()  # Refresh the admin dashboard with new data
                print("Admin dashboard updated with new user data.")
        except Exception as e:
            import traceback
            print("Error while monitoring:", e)
            traceback.print_exc()

        time.sleep(5)


def start_monitoring():
    global monitor_active, monitor_thread, lastUpdateUsersTable

    if monitor_active:
        stop_monitoring()  # Stop any existing monitoring before starting a new one
        return

    monitor_active = True
    lastUpdateUsersTable = FBconn.get("/Login/lastupdate", None)  # Init with current value
    monitor_thread = threading.Thread(target=_monitor_loop, daemon=True)
    monitor_thread.start()


def stop_monitoring():
    global monitor_active
    if monitor_active:
        monitor_active = False


def update_admin_table_only():
    global usersInfoForAdminTable, admin_table_widget

    get_users_info_from_db()

    table_html = "<table class='results-table' style='margin: auto;'>"
    table_html += "<tr><th>#</th><th>Name</th><th>Username</th><th>Status</th><th>last5Searchs</th><th>Admin</th></tr>"

    for i, user in enumerate(usersInfoForAdminTable, start=1):
        status_text = user[2]
        if "online" in status_text.lower():
            status_class = "status-online"
        elif "offline" in status_text.lower():
            status_class = "status-offline"
        else:
            status_class = "status-unknown"

        table_html += f"<tr>" \
                      f"<td>{i}</td>" \
                      f"<td>{user[0]}</td>" \
                      f"<td>{user[1]}</td>" \
                      f"<td class='{status_class}'>{status_text}</td>" \
                      f"<td>{user[3]}</td>" \
                      f"<td>{user[4]}</td>" \
                      f"</tr>"

    table_html += "</table>"

    admin_table_widget.value = table_html



# Define the callback function
def on_refresh_admin_users_table_button_click(b):
    get_users_info_from_db()       # Update usersInfoForAdminTable
    show_admin_dashboard()         # Refresh the admin dashboard

# Create the refresh button
refresh_admin_users_table_button = widgets.Button(
    description="Refresh Table",
    button_style='info',
    tooltip="Click to refresh the admin users table"
)

# Attach the callback
refresh_admin_users_table_button.on_click(on_refresh_admin_users_table_button_click)



def show_admin_dashboard():
    global usersInfoForAdminTable, currKeyUserConnected, admin_table_widget
    with tab0_content:
        tab0_content.clear_output()

        update_admin_table_only()
        update_user_table_only()
        # Create a layout with the table, index inspector, and logout button
        content = widgets.VBox(
            [
                logo_widget,
                widgets.HTML("<h2>Admin Dashboard</h2>"),
                widgets.HTML(value=f"<h3>Hello: {currConnectedUserName}</h3>"),
                addUser_btn,
                widgets.HTML("<h1> </h1>"),
                user_form_box,
                widgets.HTML("<hr>"),
                changePassword_btn,
                widgets.HTML("<h1> </h1>"),
                changePassword_form_box,
                widgets.HTML("<hr>"),
                refresh_admin_users_table_button,
                widgets.HTML("<h4> Systems users Table:</h4><div style='display:flex; justify-content:center;'>"),
                admin_table_widget,
                widgets.HTML("<hr>"),
                widgets.HTML("<h4> Your completed tasks:</h4><div style='display:flex; justify-content:center;'>"),
                user_table_widget,
                widgets.HTML("<hr>"),
                create_index_inspector(),  # Add an index inspector widget
                logout_btn  # Add a logout button
            ],
            layout=widgets.Layout(
                align_items='center',  # Center the content vertically
                justify_content='center',  # Center the content horizontally
                width='100%',  # Set width to 100%
                height='100%'  # Set height to 100%
            )
        )

        # Display the final content
        display(content)

def update_user_table_only():
    global user_table_widget, currConnectedUserName

    alluserscompletedtasks = getAllCompletedTasks()
    myCompletedTasks = alluserscompletedtasks.get(currConnectedUserName, [])

    table_html = "<table class='results-table' style='margin: auto;'>"
    table_html += "<tr><th>Taskid</th><th>title</th><th>difficulty</th><th>date</th></tr>"

    for task in myCompletedTasks:
        task_id = task.get("task_id", "N/A")
        title = task.get("title", "N/A")
        difficulty = task.get("difficulty", "N/A")
        date = task.get("date", "N/A")

        table_html += f"<tr>" \
                      f"<td>{task_id}</td>" \
                      f"<td>{title}</td>" \
                      f"<td>{difficulty}</td>" \
                      f"<td>{date}</td>" \
                      f"</tr>"

    table_html += "</table>"

    user_table_widget.value = table_html


# Define the callback function
def on_refresh_user_table_button_click(b):
    show_user_dashboard()

# Create the refresh button
refresh_user_table_button = widgets.Button(
    description="Refresh Table",
    button_style='info',
    tooltip="Click to refresh the admin users table"
)

# Attach the callback
refresh_user_table_button.on_click(on_refresh_user_table_button_click)

def getAllCompletedTasks():
    allCompletedTasksOfToday = FBconn.get(f'/gamification/completedTasks/{month}/{today}', None) or {}
    allUsersCompletedTasks = {}
    for task_id, task_data in allCompletedTasksOfToday.items():
        usercompletedTasks = []
        user_name = task_data.get("user", "")
        difficulty = task_data.get("difficulty", "")
        date = task_data.get("date", "")
        title = task_data.get("title", "")

        usercompletedTasks = allUsersCompletedTasks.get(user_name, [])
        usercompletedTasks.append({
            "task_id": task_id,
            "title": title,
            "difficulty": difficulty,
            "date": date
        })
        allUsersCompletedTasks[user_name] = usercompletedTasks
    return allUsersCompletedTasks


def show_user_dashboard():
    global currKeyUserConnected
    with tab0_content:
        tab0_content.clear_output()

        update_user_table_only()
        # Create a layout with the table, index inspector, and logout button
        content = widgets.VBox(
            [
                logo_widget,
                widgets.HTML("<h2>User Dashboard</h2>"),
                widgets.HTML(value=f"<h3>Hello: {currConnectedUserName}</h3>"),
                changePassword_btn,
                widgets.HTML("<h1> </h1>"),
                changePassword_form_box,
                widgets.HTML("<hr>"),
                refresh_user_table_button,
                user_table_widget,
                logout_btn  # Add a logout button
            ],
            layout=widgets.Layout(
                align_items='center',  # Center the content vertically
                justify_content='center',  # Center the content horizontally
                width='100%',  # Set width to 100%
                height='100%'  # Set height to 100%
            )
        )

        # Display the final content
        display(content)


# CSS Styling for LOGOUT Button (with center alignment and reduction)
style_logout_button = """
<style>
  .logout-button {
      background-color: #D32F2F;
      color: white;
      border: none;
      padding: 8px 16px;
      font-size: 14px;
      border-radius: 8px;
      cursor: pointer;
      transition: background-color 0.3s, transform 0.3s;
      margin: 0 auto;
      display: block;
  }

  .logout-button:hover {
      background-color: #B71C1C;  /* Darker red when hovering over the button */
  }

  .button-container {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 15px;
      margin-top: 20px;
      margin-bottom: 20px;
  }
</style>
"""

display(widgets.HTML(value=style_logout_button))

################################ einav added creds #########################



LOGIN_PATH = "Login/Users"
TZ_IL = pytz.timezone("Asia/Jerusalem")

############## function to get all users from DB ###########
def get_all_users() -> dict:
    users = FBconn.get(LOGIN_PATH, None)
    return users or {}


############## function to get userName specific ##########
def get_user_by_username(username: str) -> dict:
    params = {
        'orderBy': '"username"',
        'equalTo': f'"{username}"'
    }
    result = FBconn.get(LOGIN_PATH, None, params=params)
    return result or {}



def handle_login_click(b):
    global currKeyUserConnected, FBconn, lastUpdateUsersTable, currUserisAdmin, currConnectedUserName
    if not username_field.value or not password_field.value:
        login_error_message.value = "Incorrect username or password. Please try again."
        return

    entered_username = username_field.value
    entered_password = password_field.value


    usersCreds = get_user_by_username(entered_username)
    logged = False
    for key, user in usersCreds.items():
        hashed_pw = user["password"].encode()
        isAdmin = user["isAdmin"]
        #if password currect we enter the system so update last seen and showinf the dashboard
        if bcrypt.checkpw(entered_password.encode(), hashed_pw):
            FBconn.patch(f"{LOGIN_PATH}/{key}",{"lastLogin": datetime.now(TZ_IL).isoformat()})
            FBconn.patch("/Login", {"lastupdate": datetime.now(TZ_IL).isoformat()})
            lastUpdateUsersTable = FBconn.get("/Login/lastupdate", None)
            login_error_message.value = ""
            currKeyUserConnected = key
            currUserisAdmin = isAdmin
            currConnectedUserName = user["name"]
            updateTab2ContenctWithUserName()
            if isAdmin:
                get_users_info_from_db()
                start_monitoring()
                show_admin_dashboard()
            else:
                show_user_dashboard()
            resetTabs()
            logged = True
            break

    if logged == False:
        login_error_message.value = "Incorrect username or password. Please try again."

login_btn = widgets.Button(
        description="Login",
        layout=widgets.Layout(width='300px' , height='50px')
    )

login_btn.add_class("login-button")

login_btn.on_click(handle_login_click)


def add_user(name: str,
             username: str,
             password_plain: str,
             email: str,
             admin: bool = False) -> str:

    # 1. encrypting the password with hash code
    hashed_pw = bcrypt.hashpw(password_plain.encode(), bcrypt.gensalt()).decode()

    # 2. setting the default values for last login and last seen
    last_login = datetime(1990, 1, 1).isoformat()
    last_seen = datetime(1990, 1, 1).isoformat()
    searchsArray = []

    # 3. saving dic to send to DB
    data = {
        "name": name,
        "username": username,
        "password": hashed_pw,
        "email": email,
        "lastLogin": last_login,
        "lastSeen": last_seen,
        "last5Searches": searchsArray,
        "isAdmin": admin
    }

    # 4. is folder isnt there so create and if so adding
    result = FBconn.post("/Login/Users", data)
    return result["name"]          #return the key of the username

####################################### Start add user from admin page #########################################

name_input = widgets.Text(placeholder='Full Name')
email_input = widgets.Text(placeholder='Email')
username_input = widgets.Text(placeholder='Username')
password_input = widgets.Password(placeholder='Password')
is_admin_checkbox = widgets.Checkbox(description='Admin?')
add_user_status = widgets.Label(value='')

def on_submit_user_clicked(b):
    global add_user_status
    name = name_input.value.strip()
    email = email_input.value.strip()
    username = username_input.value.strip()
    password = password_input.value.strip()
    is_admin = is_admin_checkbox.value

    if not all([name, email, username, password]):
        add_user_status.value = "Please fill in all fields"
        add_user_status.style = {'color': 'red'}
        return
    userNamechecking = get_user_by_username(username)  # Check if username already exists
    if userNamechecking:
        add_user_status.value = "Username already exists. Please choose a different username."
        add_user_status.style = {'color': 'red'}
        return
    if not re.match(r"[^@]+@[^@]+\.[^@]+", email):
        add_user_status.value = "Invalid email format. Please enter a valid email."
        add_user_status.style = {'color': 'red'}
        return
    allUsersChecking = get_all_users()  # Check if email already exists
    if any(user.get('email') == email for user in allUsersChecking.values()):
        add_user_status.value = "Email already exists. Please choose a different email."
        add_user_status.style = {'color': 'red'}
        return
    generatedkey = add_user(name, username, password, email, is_admin)
    if generatedkey:
        add_user_status.value = "User created successfully!"
        add_user_status.style = {'color': 'green'}
        # Clear the input fields after successful submission
        name_input.value = ''
        email_input.value = ''
        username_input.value = ''
        password_input.value = ''
        is_admin_checkbox.value = False
    else:
        add_user_status.value = "Failed to create user. Please try again."
        add_user_status.style = {'color': 'red'}


submit_user_btn = widgets.Button(
    description="Create User",
    button_style='success'
)
submit_user_btn.add_class("submit-user-button")
submit_user_btn.on_click(on_submit_user_clicked)

submit_user_btn.layout = widgets.Layout(width='fit-content', margin='10px auto')
add_user_status.layout = widgets.Layout(width='fit-content', margin='10px auto')

user_form_box = widgets.VBox(
    [name_input, email_input, username_input, password_input, is_admin_checkbox, submit_user_btn, add_user_status],
    layout=widgets.Layout(display='none', padding='10px', border='1px solid gray', width='fit-content', margin='0 auto')
)



def handle_add_user_click(b):
    if user_form_box.layout.display == 'none':
        user_form_box.layout.display = 'block'
    else:
        user_form_box.layout.display = 'none'

addUser_btn = widgets.Button(
        description="addUser",
        layout=widgets.Layout(width='300px' , height='50px')
    )

addUser_btn.add_class("adduser-button")

addUser_btn.on_click(handle_add_user_click)

###################################### End add user from admin page #########################################

###################################### Start change password from admin page #########################################
changePassword_btn = widgets.Button(
    description="Change Password",
    layout=widgets.Layout(width='300px' , height='50px')
)
changePassword_btn.add_class("change-password-button")

newPasswordChange = widgets.Password(
    description="New Password:",
    placeholder="Enter new password",
    layout=widgets.Layout(width='400px'),
    style={'description_width': '150px'}
)

newPasswordConfirmChange = widgets.Password(
    description="Confirm Password:",
    placeholder="Confirm new password",
    layout=widgets.Layout(width='400px'),
    style={'description_width': '150px'}
)
chnagePassword_btn_form = widgets.Button(
            description="Change Password",
            button_style='success',
            layout=widgets.Layout(width='300px', height='50px')
        )
chnagePasswordLabel = widgets.Label(value="", style={'color': 'red'})
chnagePasswordLabel.layout = widgets.Layout(width='fit-content', margin='10px auto')

changePassword_form_box = widgets.VBox(
    [newPasswordChange, newPasswordConfirmChange, chnagePassword_btn_form, chnagePasswordLabel],
    layout=widgets.Layout(display='none', padding='10px', border='1px solid gray', width='450px', align_items='center', margin='0 auto')
)
def handle_change_password_click(b):
    if changePassword_form_box.layout.display == 'none':
        changePassword_form_box.layout.display = 'block'
    else:
        changePassword_form_box.layout.display = 'none'
changePassword_btn.on_click(handle_change_password_click)

def handle_change_password_submit(b):
    new_password = newPasswordChange.value.strip()
    confirm_password = newPasswordConfirmChange.value.strip()

    if not new_password or not confirm_password:
        chnagePasswordLabel.value = "Please fill in all fields."
        chnagePasswordLabel.style = {'color': 'red'}
        return

    if new_password != confirm_password:
        chnagePasswordLabel.value = "Passwords do not match."
        chnagePasswordLabel.style = {'color': 'red'}
        return

    userNameDict = get_user_by_username(currConnectedUserName)

    for key, user in userNameDict.items():
        hashed_new_password = bcrypt.hashpw(new_password.encode(), bcrypt.gensalt()).decode()
        FBconn.patch(f"{LOGIN_PATH}/{key}", {"password": hashed_new_password})
        FBconn.patch("/Login", {"lastupdate": datetime.now(TZ_IL).isoformat()})
        chnagePasswordLabel.value = "Password changed successfully!"
        chnagePasswordLabel.style = {'color': 'green'}
        # Clear the input fields after successful submission
        newPasswordChange.value = ''
        newPasswordConfirmChange.value = ''
        break
chnagePassword_btn_form.on_click(handle_change_password_submit)

################################### End change password from admin page #########################################


logout_btn = widgets.Button(
    description="Logout",
    layout=widgets.Layout(width='150px', height='50px')
)

logout_btn.add_class("logout-button")

def handle_logout_click(b):
    global currKeyUserConnected, currUserisAdmin, tabs, lastUpdateUsersTable
    # Reset all values on the admin screen and return to the login page
    username_field.value = ''  # Reset the username field
    password_field.value = ''  # Reset the password field
    login_error_message.value = ''  # Clear the error message if there is one
    if currKeyUserConnected:
        FBconn.patch(f"{LOGIN_PATH}/{currKeyUserConnected}",{"lastSeen": datetime.now(TZ_IL).isoformat()})
        FBconn.patch("/Login", {"lastupdate": datetime.now(TZ_IL).isoformat()})
        lastUpdateUsersTable = None
        currUserisAdmin = None
        currKeyUserConnected = None



    # Clear the content of the admin page
    tab0_content.clear_output(wait=True)

    # Display the login form again
    with tab0_content:
        display(widgets.VBox([  # Display the login form again
            logo_widget,
            username_field,
            password_field,
            login_btn,
            login_error_message,
            forgotPassword_btn
        ], layout=widgets.Layout(align_items='center', justify_content='center')))

    # Return to the login tab
    tabs.children = [tab0_content]
    tabs.set_title(0, 'Login Page')
    tabs.selected_index = 0

# Connect the function to the LOGOUT button
logout_btn.on_click(handle_logout_click)
backToLogin_btn.on_click(handle_logout_click)



Forgot_username_field = widgets.Text(
    description="Username:",
    placeholder="Enter username",
    layout=widgets.Layout(width='300px')
)

Forgot_email_field = widgets.Text(
    description="Email:",
    placeholder="Enter your email",
    layout=widgets.Layout(width='300px')
)

forgotPage_error_message = widgets.Label(
    value="",
    style={'color': 'red'}
)


def handle_forgot_password_click(b):
    global tabs
    Forgot_username_field.value = ''
    Forgot_email_field.value = ''
    forgotPage_error_message.value = ''


    # Clear the content of the login page
    tab0_content.clear_output(wait=True)

    # Display the forgot password form
    with tab0_content:
        display(widgets.VBox([  # Display the login form again
            logo_widget,
            Forgot_username_field,
            Forgot_email_field,
            resetMyPassword_btn,
            forgotPage_error_message,
            backToLogin_btn,
        ], layout=widgets.Layout(align_items='center', justify_content='center')))

    # Return to the login tab
    tabs.children = [tab0_content]
    tabs.set_title(0, 'Login Page')
    tabs.selected_index = 0

forgotPassword_btn.on_click(handle_forgot_password_click)



def send_password_reset_email(to_email, new_password):
    global SENDGRID_API_KEY, forgotPage_error_message
    try:
        sg = sendgrid.SendGridAPIClient(api_key=SENDGRID_API_KEY)
        message = Mail(
            from_email = "einavbs1@gmail.com",
            to_emails=to_email,
            subject='Reset Your Password',
            plain_text_content=f'''
                                    Hello,

                                    We received a request to reset your password.

                                    This is your new password:
                                    {new_password}

                                    Best regards,
                                    Corelia Turtles Group
                                    ''')
        response = sg.send(message)
        forgotPage_error_message.value = "An email has been sent to your email address with the new password."+"\n Please check your inbox and your SPAM folder."
    except Exception as e:
        forgotPage_error_message.value = "Failed to send email. Please try again later."



def generate_random_password():
    length = 12

    # Character sets
    lowercase = string.ascii_lowercase
    uppercase = string.ascii_uppercase
    digits = string.digits
    symbols = string.punctuation


    password = [
        random.choice(lowercase),
        random.choice(uppercase),
        random.choice(digits),
        random.choice(symbols)
    ]

    # Fill the rest of the password
    all_chars = lowercase + uppercase + digits + symbols
    password += random.choices(all_chars, k=length - 4)

    # Shuffle to prevent predictable order
    random.shuffle(password)

    return ''.join(password)


def handle_reset_my_password_click(b):
    userName_entered = Forgot_username_field.value.strip()
    email_entered = Forgot_email_field.value.strip()

    if not userName_entered or not email_entered:
        forgotPage_error_message.value = "Please enter both username and email."
        return
    else:
        forgotPage_error_message.value = ""
    sent = False
    userNameDict = get_user_by_username(userName_entered)
    for key, user in userNameDict.items():
        if user["username"] == userName_entered and user["email"] == email_entered:
            # If the username and email match, reset the password
            new_password = generate_random_password()
            send_password_reset_email(email_entered, new_password)
            hashed_new_password = bcrypt.hashpw(new_password.encode(), bcrypt.gensalt())
            # Update the user's password in the database
            FBconn.patch(f"{LOGIN_PATH}/{key}", {"password": hashed_new_password.decode()})
            FBconn.patch("/Login", {"lastupdate": datetime.now(TZ_IL).isoformat()})
            sent = True
            break
    if sent:
        Forgot_username_field.value = ''
        Forgot_email_field.value = ''
    else:
        forgotPage_error_message.value = "Username or email is incorrect. Please try again."


resetMyPassword_btn.on_click(handle_reset_my_password_click)


##################~ End Admin page ~###################
########################################################
########################################################


#-------------------------------------------------------------------GAMING-------------------------------------------------------------------








# HTML style for tables and headers
display(HTML("""
<style>
.centered-table {
    margin-left: auto !important;
    margin-right: auto !important;
    text-align: center;
    direction: ltr;
    border-collapse: collapse;
    font-family: Arial, sans-serif;
    width: 60%;
    table-layout: fixed;
}
.gamification-title {
    text-align: center;
    font-size: 24px;
    font-weight: bold;
    margin-top: 20px;
}
.centered-table th, .centered-table td {
    padding: 12px;
    border: 1px solid #ccc;
    text-align: center;
    width: 33.33%;
    word-wrap: break-word;
}
h4 {
    text-align: center;
    font-family: Arial, sans-serif;
    margin-top: 30px;
}
hr {
    width: 60%;
    margin-left: auto;
    margin-right: auto;
}
</style>
"""))

# Dictionary of example tasks to upload
tasks_to_upload = {
    # Easy tasks
    "task001": {"title": "Update README file", "difficulty": "easy", "points": 10, "completed": False},
    "task002": {"title": "Fix login bug", "difficulty": "easy", "points": 10, "completed": False},
    "task003": {"title": "Design homepage layout", "difficulty": "easy", "points": 10, "completed": False},
    "task004": {"title": "Add footer component", "difficulty": "easy", "points": 10, "completed": False},
    "task005": {"title": "Improve button styles", "difficulty": "easy", "points": 10, "completed": False},
    "task006": {"title": "Update contact info", "difficulty": "easy", "points": 10, "completed": False},
    "task007": {"title": "Correct typo in FAQ", "difficulty": "easy", "points": 10, "completed": False},
    "task008": {"title": "Resize logo", "difficulty": "easy", "points": 10, "completed": False},
    "task009": {"title": "Test login form", "difficulty": "easy", "points": 10, "completed": False},
    "task010": {"title": "Clean unused CSS", "difficulty": "easy", "points": 10, "completed": False},
    # Medium tasks
    "task011": {"title": "Build user profile page", "difficulty": "medium", "points": 30, "completed": False},
    "task012": {"title": "Integrate MongoDB", "difficulty": "medium", "points": 30, "completed": False},
    "task013": {"title": "Create search feature", "difficulty": "medium", "points": 30, "completed": False},
    "task014": {"title": "Add email verification", "difficulty": "medium", "points": 30, "completed": False},
    "task015": {"title": "Optimize image loading", "difficulty": "medium", "points": 30, "completed": False},
    "task016": {"title": "Create pagination system", "difficulty": "medium", "points": 30, "completed": False},
    "task017": {"title": "Add user avatar upload", "difficulty": "medium", "points": 30, "completed": False},
    "task018": {"title": "Filter table results", "difficulty": "medium", "points": 30, "completed": False},
    "task019": {"title": "Setup role-based access", "difficulty": "medium", "points": 30, "completed": False},
    "task020": {"title": "Add language selector", "difficulty": "medium", "points": 30, "completed": False},
    # Hard tasks
    "task021": {"title": "Automate test pipeline", "difficulty": "hard", "points": 50, "completed": False},
    "task022": {"title": "Implement dark mode toggle", "difficulty": "hard", "points": 50, "completed": False},
    "task023": {"title": "Deploy to Firebase hosting", "difficulty": "hard", "points": 50, "completed": False},
    "task024": {"title": "Create admin dashboard", "difficulty": "hard", "points": 50, "completed": False},
    "task025": {"title": "Configure CI/CD with GitLab", "difficulty": "hard", "points": 50, "completed": False},
    "task026": {"title": "Build analytics panel", "difficulty": "hard", "points": 50, "completed": False},
    "task027": {"title": "Secure API endpoints", "difficulty": "hard", "points": 50, "completed": False},
    "task028": {"title": "Real-time notifications", "difficulty": "hard", "points": 50, "completed": False},
    "task029": {"title": "Implement WebSocket chat", "difficulty": "hard", "points": 50, "completed": False},
    "task030": {"title": "Backup & restore feature", "difficulty": "hard", "points": 50, "completed": False},
}


def upload_tasks_to_firebase():
    dailyreset = FBconn.get('/gamification/lastDailyReset', None)
    if dailyreset is None or dailyreset != today:
        for task_id, task_data in tasks_to_upload.items():
            FBconn.put('/gamification/taskBank/', task_id, task_data)


# Prepare tracking info
upload_tasks_to_firebase()
difficulty_points = {"easy": 10, "medium": 30, "hard": 50}
usernames = get_all_users()
all_tasks = FBconn.get('/gamification/taskBank', None)


############################### table score functions ###############################

dailyRanksWidget = widgets.HTML()
df_daily = {}


monthlyRanksWidget = widgets.HTML()
df_monthly = {}

taskTableWidget = widgets.HTML("<table class='results-table' style='margin: auto;'>" +
                                 "<tr><th>Difficulty</th><th>Points</th></tr>"+
                                 "<tr><td>Easy</td><td>10</td></tr>" +
                                 "<tr><td>Medium</td><td>30</td></tr>" +
                                 "<tr><td>Hard</td><td>50</td></tr></table>")

def DisplayDailyRanks():
    global df_daily, dailyRanksWidget
    df_daily = calculateDailyScore()
    df_daily = dict(sorted(df_daily.items(), key=lambda item: item[1], reverse=True))

    table_html = "<table class='results-table' style='margin: auto;'>"
    table_html += "<tr><th>Rank</th><th>Name</th><th>Score</th></tr>"

    for i, user in enumerate(df_daily, start=1):
        if i == 1:
            status_class = "first-place"
        elif i == len(df_daily):
            status_class = "last-place"
        else:
            status_class = "normal-place"

        table_html += f"<tr>" \
                      f"<td>{i}</td>" \
                      f"<td>{user}</td>" \
                      f"<td class='{status_class}'>{df_daily.get(user, 0)}</td>" \
                      f"</tr>"

    table_html += "</table>"

    dailyRanksWidget.value = table_html


def DisplayMonthlyRanks():
    global df_monthly, monthlyRanksWidget
    df_monthly = calculateDailyScore()
    df_monthly = dict(sorted(df_monthly.items(), key=lambda item: item[1], reverse=True))

    table_html = "<table class='results-table' style='margin: auto;'>"
    table_html += "<tr><th>Rank</th><th>Name</th><th>Score</th></tr>"

    for i, user in enumerate(df_monthly, start=1):
        if i == 1:
            status_class = "first-place"
        elif i == len(df_monthly):
            status_class = "last-place"
        else:
            status_class = "normal-place"

        table_html += f"<tr>" \
                      f"<td>{i}</td>" \
                      f"<td>{user}</td>" \
                      f"<td class='{status_class}'>{df_monthly.get(user, 0)}</td>" \
                      f"</tr>"

    table_html += "</table>"

    monthlyRanksWidget.value = table_html


def calculateDailyScore(today=today, month=month):
    allCompletedTasksOfToday = FBconn.get(f'/gamification/completedTasks/{month}/{today}', None)
    users = get_all_users()
    dailyScoreDic = {}
    for user_id, user in users.items():
        dailyScoreDic[user["name"]] = 0

    if not allCompletedTasksOfToday:
        return dailyScoreDic
    for task_id, task_data in allCompletedTasksOfToday.items():
        user_name = task_data.get("user", "")
        difficulty = task_data.get("difficulty", "")
        points = difficulty_points.get(difficulty, 0)
        if user_name in dailyScoreDic:
            dailyScoreDic[user_name] += points

    return dailyScoreDic


def calculateMonthlyScore(month=month):
    allDaysinMonth = FBconn.get(f'/gamification/completedTasks/{month}', None)
    monthlyScoreDic = {}
    for day, daydata in allDaysinMonth.items():
        dailyScore = calculateDailyScore(today=day, month=month)
        for user, score in dailyScore.items():
            if user not in monthlyScoreDic:
                monthlyScoreDic[user] = score
            else:
                monthlyScoreDic[user] += score
    return monthlyScoreDic


################################## end score calculation functions ###############################

gamingErrMsg = widgets.Label(value="", style={'color': 'red'})

def findTaskIdByTitle(title):
    for task_id, task in all_tasks.items():
        if task.get("title") == title:
            return task_id
    return None

def complete_task():
    global gamingErrMsg, tasks_dic
    selectedTask = task_dropdown.value
    selectedDifficulty = difficulty_dropdown.value
    if not tasks_dic:
        gamingErrMsg.value ="No tasks available to complete."
        gamingErrMsg.style={'color': 'red'}
        return
    if not selectedTask or not selectedDifficulty:
        gamingErrMsg.value ="Please select a task and difficulty level."
        gamingErrMsg.style={'color': 'red'}
        return
    gamingErrMsg.value = "Wait while update task as done"
    gamingErrMsg.style = {'color': 'green'}
    selectTaskId = findTaskIdByTitle(selectedTask)
    FBconn.patch(f'/gamification/completedTasks/{month}/{today}/{selectTaskId}', {'title': selectedTask, 'difficulty': selectedDifficulty, 'user': currConnectedUserName, 'date': today})
    FBconn.patch(f'/gamification/taskBank/{selectTaskId}', {'completed': True})
    updateTaskDropdown()

task_dropdown = widgets.Dropdown(options=[], description='Task:')

difficulty_dropdown = widgets.Dropdown(
    options=[('Easy', 'easy'), ('Medium', 'medium'), ('Hard', 'hard')],
    description='Difficulty:'
)


def on_difficulty_change(change):
    selected = change['new']
    updateTaskDropdown()

difficulty_dropdown.observe(on_difficulty_change, names='value')


def updateTasksToComplete():
    global tasks_dic
    tasks_dic = {}
    tasksinDB = FBconn.get('/gamification/taskBank', None)
    easy = []
    medium = []
    hard = []
    for task_id, task in tasksinDB.items():
        if not task.get('completed', False):
            title = task['title']
            difficulty = (task.get('difficulty','')).lower()
            if difficulty == 'easy':
                easy.append(title)
            elif difficulty == 'medium':
                medium.append(title)
            elif difficulty == 'hard':
                hard.append(title)

    for listName, createdList in zip(['easy', 'medium', 'hard'],[easy, medium, hard]):
        if createdList:
            tasks_dic[listName] = createdList

def updateTaskDropdown():
    global gamingErrMsg, tasks_dic, task_dropdown, difficulty_dropdown
    previousSelectedDifficulty = difficulty_dropdown.value
    updateTasksToComplete()
    difficulty_dropdown.options = list(tasks_dic.keys()) if tasks_dic else []
    if difficulty_dropdown.options and previousSelectedDifficulty in difficulty_dropdown.options:
        difficulty_dropdown.value = previousSelectedDifficulty
    else:
        difficulty_dropdown.value = difficulty_dropdown.options[0] if difficulty_dropdown.options else None

    selectedDifficulty = difficulty_dropdown.value
    task_dropdown.options = tasks_dic.get(selectedDifficulty, [])
    task_dropdown.value = task_dropdown.options[0] if task_dropdown.options else None

    gamingErrMsg.value=""
    gamingErrMsg.style={'color': 'red'}
    DisplayDailyRanks()
    DisplayMonthlyRanks()



updateTaskDropdown()

completeTask_btn = widgets.Button(description='âœ… Complete Task', button_style='success')
completeTask_btn.on_click(lambda x: complete_task())



############### End Gaming ######################
########################################################
########################################################





#-------------------------------------------------------------------INFORMATION-------------------------------------------------------------------

# HTML style similar to Gamification section
display(HTML("""
<style>
    .info-container {
        margin-left: auto;
        margin-right: auto;
        font-family: Arial, sans-serif;
        width: 70%;
        table-layout: fixed;
    }
    .info-container h2,
    .info-container h3,
    .info-container p {
        margin-top: 10px;
        margin-bottom: 10px;
    }
    .info-container hr {
        margin: 20px 0;
        border: 0;
        height: 1px;
        background-color: #ccc;
    }
</style>
"""))

############### End information ######################
########################################################
########################################################


#-------------------------------------------------------------------CHATBOT-------------------------------------------------------------------
display(widgets.HTML("""
<style>
    .chatbot-container {
        width: 90%;
        max-width: 800px;
        margin: auto;
        font-family: Arial, sans-serif;
    }
    .chatbot-input-row {
        display: flex;
        gap: 10px;
        margin-top: 10px;
    }
    .chatbot-output {
        border: 1px solid #ccc;
        padding: 10px;
        border-radius: 10px;
        min-height: 200px;
        background: #f9f9f9;
        margin-top: 10px;
        overflow-y: auto;
        max-height: 400px;
    }
</style>
"""))


# Gemini API Key configuration
genai.configure(api_key='AIzaSyBOZAHEfSecdB67CBaRB3fiCcJBrz9skFM')

# Load the Gemini model
gemini_model = genai.GenerativeModel("gemini-1.5-flash")
chat_output = widgets.Output()
chat_output.add_class("chatbot-output")

chat_input = widgets.Text(
    placeholder='Ask me anything...',
    layout=widgets.Layout(flex='1')
)

chat_send_btn = widgets.Button(
    description="Send",
    button_style='success',
    layout=widgets.Layout(width='100px')
)

# === Chat logic ===
def on_message(sender=None):
    prompt = chat_input.value.strip()
    chat_input.value = ''
    if not prompt:
        return
    with chat_output:
        display(Markdown(f"**You:** {prompt}"))
        try:
            response = gemini_model.generate_content(get_augmented_prompt(prompt))
            display(Markdown(f"**Chatbot:** {response.text}"))
        except Exception as e:
            display(Markdown(f"**Error:** {e}"))

chat_send_btn.on_click(on_message)

# === Assemble the interface ===
chat_input_row = widgets.HBox([chat_input, chat_send_btn])
chat_input_row.add_class("chatbot-input-row")

logo_box = widgets.VBox([logo_widget], layout=widgets.Layout(align_items='center', justify_content='center'))

tab6_content = widgets.VBox(
    [logo_box, chat_output, chat_input_row],
    layout=widgets.Layout(gap='20px')
)

# display(widgets.VBox(
#         [logo_widget, refresh_button],
#         layout=widgets.Layout(align_items='center', justify_content='center', gap='20px'),[chat_output, chat_input_row]
#     ))


tab6_content.add_class("chatbot-container")



#---------------------------------------------------Q-A-CHATBOT-----------------------------------------------------------
def get_augmented_prompt(user_question):
    faq_pairs = [
        {"question": "What is the goal of the project?", "answer": "The goal is to build a cloud-based system for task management, graphs, indexing, and gamification."},
        {"question": "Where is the data stored?", "answer": "All data is stored in Firebase Realtime Database."},
        {"question": "What does indexing mean in your project?", "answer": "We crawl mqtt.org and extract keywords using stop-word removal and stemming."},
        {"question": "How is text processed?", "answer": "We tokenize, remove stop words, and apply Porter stemming to normalize words."},
        {"question": "What is the chatbot based on?", "answer": "The chatbot uses Gemini API from Google and is integrated in Colab using ipywidgets."},
        {"question": "How do I search for a word?", "answer": "The system searches for the stemmed version of the word in the Firebase index."},
        {"question": "Which word appears in the most pages?", "answer": "The word 'mqtt' appears in the most links in the index."},
        {"question": "Which page contains the most keywords?", "answer": "The page https://mqtt.org/docs contains the most indexed words."},
        {"question": "How is the inverted index built?", "answer": "We extract words from web pages and store them in Firebase as word â†’ list of URLs."},
        {"question": "What is an inverted index?", "answer": "An inverted index maps each word to the URLs in which it appears."},
        {"question": "How does the search engine work?", "answer": "It processes your input, applies stemming, and finds matching entries from the index."},
        {"question": "What does the I'm Feeling Lucky button do?", "answer": "It opens the best matching result based on the number of keyword hits."},
        {"question": "What happens if no results are found?", "answer": "An error message is shown and the user is redirected back to the search tab."},
        {"question": "How are search results displayed?", "answer": "They are shown in a table with rank, domain, and a link to each page."},
        {"question": "Can I refresh the index?", "answer": "Yes, clicking the refresh button will re-index the site and update Firebase."},
        {"question": "What data is shown in the graphs tab?", "answer": "Temperature, humidity, air pressure, user activity, and daylight data."},
        {"question": "Where does the graph data come from?", "answer": "The data is simulated, originally intended to be collected via MQTT."},
        {"question": "What is the time range in the graphs?", "answer": "The graphs show data for the past 6 days."},
        {"question": "Is the graph data real-time?", "answer": "Currently the data is simulated, but the system supports real-time updates via MQTT."},
        {"question": "What does the daylight chart display?", "answer": "It shows sunrise, sunset, and total daylight hours for each day."},
        {"question": "How does gamification work?", "answer": "Users are assigned tasks with different difficulty levels and earn points."},
        {"question": "What are the difficulty levels?", "answer": "Easy (10 points), Medium (30 points), Hard (50 points)."},
        {"question": "How are tasks assigned?", "answer": "Select a user, choose a difficulty, pick a task, and mark it as completed."},
        {"question": "Are scores saved?", "answer": "Yes, daily and monthly scores are saved in Firebase under each user."},
        {"question": "Can tasks reset daily?", "answer": "Yes, completed tasks reset each day and are archived."},
        {"question": "What is Firebase?", "answer": "Firebase is a cloud backend by Google offering storage, authentication, and real-time database."},
        {"question": "How do you connect to Firebase?", "answer": "Using the firebase Python library which sends REST API calls to the database."},
        {"question": "What data is stored in Firebase?", "answer": "We store the inverted index, user scores, tasks, and task history."},
        {"question": "How is word index stored?", "answer": "Each stemmed word maps to a list of URLs under /myMqttIndex."},
        {"question": "How is score stored?", "answer": "Scores are saved by user and date under /gamification/tasks/<month>/<user>."},
        {"question": "What is Gemini API?", "answer": "It's a conversational model from Google used to generate smart responses to user input."},
        {"question": "How did you add a chatbot?", "answer": "Using generativeai with ipywidgets and Colab to connect to Gemini API."},
        {"question": "Does the chatbot remember past messages?", "answer": "It uses context injection during runtime, but does not persist memory."},
        {"question": "Can the chatbot answer technical questions?", "answer": "Yes, if they match one of the known indexed examples or FAQ patterns."},
        {"question": "What happens when a new question is asked?", "answer": "The model tries to infer the answer from the enriched examples provided in the prompt."},
        {"question": "Who built the project?", "answer": "Software engineering students as part of a Cloud Computing course."},
        {"question": "What is the main advantage of the system?", "answer": "It combines search, graphs, gamification, and smart interaction in one cloud platform."},
        {"question": "Is this project open-source?", "answer": "Yes, the code can be reused and extended in other educational or research projects."},
        {"question": "Can I use this system for my own project?", "answer": "Yes, especially if you're working on search, analytics, or gamification."},
        {"question": "How was the UI built?", "answer": "Using ipywidgets, custom CSS, and matplotlib for data visualization."},
        {"question": "What language is the backend written in?", "answer": "The backend and all logic are written in Python, running on Google Colab."},
        {"question": "How are sunrise/sunset times generated?", "answer": "They are simulated using random values in realistic ranges."},
        {"question": "What kind of feedback do users get?", "answer": "They see score tables and confirmation messages for completed tasks."},
        {"question": "Is the chatbot case-sensitive?", "answer": "No, the input is normalized before sending it to Gemini."},
        {"question": "How many tasks can a user complete per day?", "answer": "There's no strict limit, but tasks reset daily."},
        {"question": "Can I export the indexed words?", "answer": "Yes, there's an export button in the admin tab that generates a .txt file."},
        {"question": "What is the stop words list?", "answer": "A list of common English words (like 'the', 'is', etc.) removed before indexing."},
        {"question": "What is stemming?", "answer": "Stemming reduces words to their root form, e.g., 'connected' â†’ 'connect'."},
        {"question": "What happens if I refresh the dashboard?", "answer": "All graphs and data are regenerated with new fake values."}
    ]

    intro = "You are an assistant helping users interact with a cloud-based dashboard that includes a search engine, word indexing, gamification, and sensor visualizations. Use the examples below to guide your answer."
    examples = "\n\n".join([f"Q: {q['question']}\nA: {q['answer']}" for q in faq_pairs])
    return f"{intro}\n\n{examples}\n\nQ: {user_question}\nA:"




############### END CHATBOT ######################
########################################################
########################################################

########################################################
########################################################
# Tabs

# Display admin tab
tab0_content = widgets.Output()
with tab0_content:
    username_field = widgets.Text(
        description="Username:",
        placeholder="Enter username",
        layout=widgets.Layout(width='300px')
    )

    password_field = widgets.Password(
        description="Password:",
        placeholder="Enter password",
        layout=widgets.Layout(width='300px')
    )

    login_error_message = widgets.Label(
        value="",
        style={'color': 'red'}
    )
    display(widgets.VBox([
        logo_widget,
        username_field,
        password_field,
        login_btn,
        login_error_message,
        forgotPassword_btn
    ], layout=widgets.Layout(align_items='center', justify_content='center')))



# Display graphs tab
with tab1_content:
    display(widgets.VBox(
        [logo_widget, refresh_button],
        layout=widgets.Layout(align_items='center', justify_content='center', gap='20px')
    ))
    cards, temp_humidity_img, pressure_img, users_img, temp_range_img, daylight_hours_img, sun_times_img = update_dashboard()
    display(widgets.HTML(value=cards))

    display(widgets.VBox(
    [
        pil_to_widget_img(temp_humidity_img),
        pil_to_widget_img(pressure_img),
        pil_to_widget_img(users_img),
        pil_to_widget_img(temp_range_img),
        pil_to_widget_img(daylight_hours_img),
        pil_to_widget_img(sun_times_img)
    ],
    layout=widgets.Layout(
        align_items='center',
        justify_content='center',
        display='flex',
        flex_direction='column',
        gap='100px'
    )
))
tab2_content = widgets.VBox()
# Display gamification tab
def updateTab2ContenctWithUserName():
    global tab2_content, currConnectedUserName, dailyRanksWidget, monthlyRanksWidget
    tab2_content = widgets.VBox([logo_widget,
        widgets.HTML('<h3 class="gamification-title">Gamification - Employee Scoring</h3>'),
        widgets.HTML('<h3>Hello  ' + currConnectedUserName  + '</h3>'),
        widgets.HTML('<h3>Please select a task to complete: </h3>'),
        widgets.HBox([difficulty_dropdown, task_dropdown, completeTask_btn],
                    layout=widgets.Layout(justify_content='flex-end', padding='10px')),
        gamingErrMsg,
        widgets.HTML("<hr>"),
        widgets.HTML("<h4> Tasks Score Table</h4><div style='display:flex; justify-content:center;'>"),
        taskTableWidget,
        widgets.HTML("<hr>"),
        widgets.HTML("<h4>ğŸ“… daily Score Table</h4><div style='display:flex; justify-content:center;'>"),
        dailyRanksWidget,
        widgets.HTML("<hr>"),
        widgets.HTML("<h4>ğŸ“… Monthly Score Table</h4><div style='display:flex; justify-content:center;'>"),
        monthlyRanksWidget
    ], layout=widgets.Layout(padding='30px', border='1px solid #ccc', align_items='center'))

# Display search tab
tab3_content = widgets.Output()
with tab3_content:
    display(main_container)

tab4_content = widgets.Output()
with tab4_content:
    display(widgets.VBox([logo_widget, searchResults],
                         layout=widgets.Layout(align_items='center')))




# Content of the info tab
tab5_content = widgets.Output()

with tab5_content:
    display(widgets.VBox(
        [logo_widget],
        layout=widgets.Layout(align_items='center', justify_content='center')
    ))
    display(HTML("""
    <div class='info-container'>
        <h2>â„¹ï¸ Transparency & Information</h2>
        <hr>

        <h3>ğŸ” Admin Tab</h3>
        <p>This tab allows system administrators to view user activity and access the word indexing tools.
        No personal data is stored â€“ only usernames and word statistics from public web indexing.</p>

        <h3>ğŸ“ˆ Graphs Tab</h3>
        <p>This tab visualizes sensor data such as temperature, humidity, pressure, and daylight information.
        The data is simulated (fake) for demonstration purposes. No actual user data is collected or stored.</p>

        <h3>ğŸ® Gamification Tab</h3>
        <p>Users earn points for completing predefined tasks. Each task is assigned a difficulty level (easy/medium/hard),
        which determines its score (10/30/50 points). Scores are stored per user in Firebase using their usernames only.</p>

        <h3>ğŸ” Search Tab</h3>
        <p>This search engine indexes and searches content from the mqtt.org website. It uses stop-word removal and word stemming to improve results.
        No personal data is stored â€“ searches are not logged or tracked.</p>


        <hr>
        <p style='font-size:13px; color:gray;'>This system was built as an educational project for cloud computing. All data processing is transparent and privacy-conscious.</p>
    </div>
    """))


login_tab_content = widgets.Output()

with login_tab_content:
    display(widgets.VBox([
        logo_widget,
        username_field,
        password_field,
        login_btn,
        login_error_message
    ], layout=widgets.Layout(align_items='center')))




tabs = widgets.Tab(children=[
    tab0_content,
], layout=widgets.Layout(width='1200px', height='800px'))

tabs.set_title(0, 'Login Page')





display(tabs)


text = """
cloud computing and machine learning &nbsp;&nbsp;&nbsp;&nbsp; the best cloud computing platform &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2025 cloud computing trends<br>
top 10 mqtt brokers &nbsp;&nbsp;&nbsp;&nbsp; cloud computing introduction for beginners &nbsp;&nbsp;&nbsp;&nbsp; data science using python &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;machine learning basics
"""

html_content = f"""
    <p style="color: #C0C0C0; padding: 10px; font-size: 10px;">{text}</p>
"""

display(widgets.HTML(value=html_content))